


UGSA.
base search is best-first on u. f is g + remcost (as returned by abtsearch).

//abtsearch is best-first on u = F(g, depth) = wf * g + sum(hbf ** [baseState.depth, baseState.depth + depth]) <- true u

abtsearch is best-first on u = F(g, depth) = wf * g + sum(hbf ** [0, depth])
is lower bound on 'true' u.


returns (g,depth,u) of solution with best u. g is it's path cost, depth is its depth.

hbf is online estimation. If not resorting, hbf used in each instance of abtsearch is up-to-date (i.e. better than in prev instances).
If resorting, hbf constant, recalculated between phases. openlist also recalculated and resorted between phases.



var USE_RESORT = ...
var RESORT_FACT = ...
var INIT_RESORT_EXPD = ...


ugsa_d(s0):
	var openlist, closedlist //Openlist is ordered on min u, then min f, then max g.
	
	var expStats  //maps g,f,depth -> number of expanded nodes at that level for f/g/depth.
	var hbf = 1
	
	if USE_RESORT:
		var expdAtNextResort = INIT_RESORT_EXPD
		var phaseHBF = 1

	
	var ucalc =  [ abt_g, abt_depth -> wf * abt_g + sum(hbf ** [0, abt_depth]) ] 
	var abtRes = abtsearch(s0, ucalc)
	
	n0 = {	state:s0,
			g:0,
			depth:0,
			f: abtRes.g,
			u: abtRes.u,
			in_op:NOOP,
			parent_op:NOOP,
			parent:null
			}

	openlist.push(n0), closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		
		if n.state is goal:
			//return solution (s0 to n)
		
		expStats.add(n)
		
		hbf = computeHBF(expStats)
		
		var ops = n.state.ops
		
		for op in ops:
			if op == n.parent_op:
				continue
		
			var Edge e = createEdge(n.state, op)
			
			kid_depth = n.depth + 1
			
			_hbf = phaseHBF if DO_RESORT else computeHBF(expStats)
			
			abtRes = abtsearch(e.state(), ucalc)
			
			var childNode = {state:		e.state,
							 g:			n.g+e.cost,
							 depth:		n.depth+1,
							 f:			g + abtRes.g,
							 u:			wf * g + abtRes.u,
							 in_op:		op,
							 parent_op:	e.parent_op,
							 parent:	n
							 }
			
			if closedlist.contains(childNode.state):
				dup = closedlist.find(childNode.state)
				
				if dup.g > childNode.g:
					closedlist.remove(dup)
					
					if openlist.contains(dup):				
						openlist.remove(dup)
				
					openlist.push(childNode)
					closedlist.add(childNode)
			else:
				openlist.push(childNode)
				closedlist.add(childNode)
		
		if USE_RESORT and expStats.expd >= expdAtNextResort :
			
			phaseHBF = computeHBF(expStats)
		
			for n in openlist:
				abtRes = abtsearch(e.state(), [ abt_g, abt_depth -> wf * abt_g + sum(phaseHBF ** [n.depth, n.depth+abt_depth]) ] )
				n.u = abtRes.u

			expdAtNextResort *= RESORT_FACT




abtsearch(baseState, ucalc):	//ucalc is function object

	var openlist, closedlist //Openlist is ordered on min u, then max g.

	n0 = {	state:abstract(baseState), 
			g:0, 
			depth:0,
			u:ucalc(g, depth),
			in_op:NOOP,
			parent_op:NOOP,
			parent:null
			}
	openlist.push(n0), closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		
		if n.state is goal:
			return {g:n.g, depth:n.depth, u:n.u}

		var ops = n.state.ops
		
		for op in ops:
			if op == n.parent_op:
				continue
		
			var Edge e = createEdge(n.state, op)
			
			var childNode = {state:		e.state,
							 g:			n.g+e.cost,
							 depth:		n.depth+1,
							 u:			ucalc(g, depth),
							 in_op:		op,
							 parent_op:	e.parent_op,
							 parent:	n,
						}
			
			if closedlist.contains(childNode.state):
				dupNode = closedlist.find(childNode.state)
				
				if dupNode.u > childNode.u:
					closedlist.remove(dupNode)
					
					if openlist.contains(dupNode):				
						openlist.remove(dupNode)
				
					openlist.push(childNode)
					closedlist.add(childNode)
			
			else:
				openlist.push(childNode)
				closedlist.add(childNode)



computeHBF(expStats):
	hbf = //best fit for expStats.N(f) == hbf ** (f - expStats.f0) for f in expStats.observedFLevels
	return hbf
