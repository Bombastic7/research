



-- Base Search --

struct Node { state, g, depth, f, u, parent }


openlist = list of Nodes, ordered on min u, then min f, then max g.
closedlist = plain set of Nodes.



ugsa_base_search(s0):
	n0 = { state=s0, g=0, depth=0 }
	
	eval_heuristics(n0)
	openlist.push(n0)
	closedlist.add(n0)
	
	loop:
		n = open.pop()
		if n.state is goal:
			return solution
		
		expand(n)


expand(n):
	for each child of n.state:
	
		if child == n.parent.state:
			continue
	
		edge = edge of n.state to child
		
		childnode = Node {state=child, g = n.g + edge.cost, depth = n.depth + 1, parent=n}
		
		eval_heuristics(childnode)
		
		
		if child in closedlist and dupnode.g > childnode.g:
			remove dupnode from closedlist, and openlist if present.
		
		
		if child not in closedlist:
			openlist.push(childnode)
			closedlist.add(childnode)



eval_heuristics(n):
	struct pair { fval, uval }
	
	candidates = vector of pair
	
	For each (cost-to-go, dist-to-go) available for n->state:
		n.f = n->g + cost-to-go
		uval = eval_u(n, cost-to-go, dist-to-go)
		
		candidates.add( {fval=n.f, uval=uval} )
		
	best = x in candidates where x.uval is minimal
	n.f = best.fval
	n.u = best.uval


eval_u(n, h, d):
	return ...


/*
	eval_heuristics(n) determines one or more (cost-to-go, distance-to-go) pairs for n.state. This is a static mapping.
	Sets n.f. Sets n.u by refering to eval_u(n, h, d)
	
	eval_u(n, h, d) returns n's u using n's g, f, depth, and supplied h and d arguments, as well as dynamically changing 
	search behaviour statistics.
	
	Thus there are two components that can be seperated: the method in eval_heuristics() to compute one or more h/d heuristic values,
	and the method used to determin a node's u value.
	
	Min_Cost: 			return cost and depth of the cheapest solution path in abstract space.
	Min_Dist: 			return cost and depth of the shortest.
	Min_Cost_Or_Dist: 	minimum of Min_Cost and Min_Dist.
	Min_Cost_And_Dist: 	return cost of cheapest path, depth of shortest path.
	
	
	Compute u methods:
	
	Delay: u = wf*f + d * [avg expansions between a node being generated and expanded]
	
	HBF: u = wf*f + bf ** (depth+d) - bf ** depth,  where bf is the heuristic branching factor (on u) of the base space.
*/
