#pragma once


#include <array>
#include <vector>
#include <fstream>
#include <string>
#include <random>


namespace mjon661 { namespace gridnav { namespace cube_blocked {



	enum struct Cell_t {
		Open, Blocked, Null
	};



	template<typename = void>
	class CellMap {
		
		public:
		
		class OpenCellIterator {
			public:
			
			OpenCellIterator& operator++() {
				if(mIdx == mInst.getSize())
					return *this;
				++mIdx;
				while(true) {
					bool v = mIdx < mInst.getSize();
					if(!v)
						break;
					
					bool o = mInst.isOpen(mIdx);
					if(o)
						break;
					++mIdx;
				}
				/*
				do {
					++mIdx;
				} while(mIdx < mInst.getSize() && !mInst.isOpen(mIdx));
				*/
				return *this;
			}
			
			bool operator==(OpenCellIterator const& o) {
				return mIdx == o.mIdx;
			}
			
			bool operator!=(OpenCellIterator const& o) {
				return mIdx != o.mIdx;
			}
			
			unsigned operator*() {
				return mIdx;
			}
			
			private:
			friend CellMap<void>;
			
			OpenCellIterator(CellMap<void> const& pInst, bool pAtEnd) :
				mInst(pInst),
				mIdx(0)
			{
				slow_assert(pInst.mCells.size() == pInst.getSize());
				if(pAtEnd)
					mIdx = mInst.getSize();
				else
					while(mIdx < mInst.getSize() && !mInst.isOpen(mIdx))
						++mIdx;
			}
			
			CellMap<void> const& mInst;
			unsigned mIdx;
		};
		
		
		CellMap(unsigned pSize, std::string const& pMapFile) :
			mSize(pSize),
			mCells(mSize)
		{
			if(pMapFile[0] == '.') {
				unsigned seed = std::strtol(pMapFile.c_str()+1, nullptr, 10);
				initRandomMap(seed);
			}
			else {
				std::ifstream ifs(pMapFile);
				
				if(!ifs)
					throw std::runtime_error("Could not open map file");

				for(unsigned i=0; i<mSize; i++) {
					int v;
					Cell_t c;
					ifs >> v;
					c = (Cell_t)v;
					
					gen_assert(c == Cell_t::Open || c == Cell_t::Blocked);
					mCells[i] = c;
				}
			}
		}
		
		
		std::vector<Cell_t> const& cells() const {
			return mCells;
		}
		
		unsigned getSize() const {
			return mSize;
		}
		
		bool isOpen(unsigned i) const {
			slow_assert(i < mSize, "%u %u", i, mSize);
			return cells()[i] == Cell_t::Open;
		}
		
		OpenCellIterator begin() const {
			return OpenCellIterator(*this, false);
		}
		
		OpenCellIterator end() const {
			return OpenCellIterator(*this, true);
		}
		
		private:
		
		void initRandomMap(unsigned seed) {
			std::mt19937 gen(5489u + seed);
			std::uniform_real_distribution<double> d(0.0,1.0);
			
			for(unsigned i=0; i<mSize; i++) {
				mCells[i] = d(gen) <= 0.35 ? Cell_t::Blocked : Cell_t::Open;
			}
			
			logDebugStream() << "Random CellMap init. seed=" << seed << ", blockedprob=0.35" << "\n";
		}
		
		const unsigned mSize;
		std::vector<Cell_t> mCells;
	};
	
	
	
	//Generates set of AdjOp.
	//Each AdjOp is an array of pairs {affected dimension, increment or decrement}.
	
	//For an N-dimensional domain, an adjacent state can be generated by choosing 1 to N dimensions to change, and for each of those
	//	dimensions whether to increment or decrement along it.

	//Cost is implied to be sqrt(AdjOp::size());
	
	template<unsigned N>
	struct AdjOpSet {
		
		using DimMod = std::pair<unsigned, bool>;
		using AdjOp = std::array<DimMod, N+1>;
		
		static const unsigned Null_Idx = (unsigned)-1;
		
		
		void prettyPrint(AdjOp const& op, std::ostream& out) {
			for(unsigned i=0; i<N; i++) {
				if(op[i].first == Null_Idx)
					break;
				
				out << op[i].first;
				if(op[i].second)
					out << "+ ";
				else
					out << "- ";
				
			}
		}
		
		AdjOp const& getOp(unsigned i) {
			slow_assert(i < mAdjOps.size());
			return mAdjOps[i];			
		}
		
		unsigned size() {
			return mAdjOps.size();
		}
		
				
		AdjOpSet() {
			
			//Iterate number of affected dimensions. N loops.
			for(unsigned k=1; k<=N; k++) {

				//Iteratate k-combinations of N dimensions. N!/(k!/(N-k)!) loops.
				std::array<bool,N> tgtDims;
				std::fill(tgtDims.begin(), tgtDims.end(), false);

				for(unsigned i=N-1, j=0; j<k; i--, j++)
					tgtDims.at(i) = true;
				
				do {
					//Iterate increment/decrement of k affected dimensions. 2 ** k loops.
					unsigned incr = 0; //bitmask, one for each of the k selected dimensions. True/false for increment/decrement.
					
					do {
						AdjOp op;
						
						for(unsigned i=0; i<op.size(); i++)
							op.at(i).first = Null_Idx;
						
						for(unsigned i=0, d=0; i<N; i++, d++) {
							if(!tgtDims[i]) {
								d--;
								continue;
							}
									
							op.at(d).first = i;
							op.at(d).second = (incr >> d) & 1;
						}
						
						mAdjOps.push_back(op);
						incr++;
						
					} while(incr < (1u << k));
				} while(std::next_permutation(tgtDims.begin(), tgtDims.end()));

			}
		}
		
		std::vector<AdjOp> mAdjOps;
	};
	
	
	
	template<unsigned N>
	struct AdjStateSet {
		using State = std::array<unsigned, N>;
		using PackedState = unsigned;
		
		
		PackedState packState(State const& s) {
			PackedState pkd = 0;
			unsigned rdx = 1;
			
			for(unsigned i=0; i<N; i++) {
				pkd += s[i] * rdx;
				rdx *= mDimSz[i];
			}
			
			return pkd;
		}
		
		State unpackState(PackedState pkd) {
			State s;
			
			rdx = mDimSz[0];
			
			for(unsigned i=0; i<N-1; i++) {
				s[i] = pkd % mDimSz[i+1];
				pkd /= rmDimSz[i+1];
			}
			
			s[N-1] = pkd;
			
			return s;
		}
		
		
		struct AdjEdgeIterator {
			
			AdjEdgeIterator(std::vector<AdjOp> const& pOps, State const& pState) :
				mOps(pOps),
				mNextOp(0),
				mState(pState)
			{
				mChangeDims.fill(false);
			}
			
			State& state() {
				return mAdjState;
			}
			
			
			private:
			bool advState() {
				mAdjState = mState;
				
				while(true) {
					mCurOp++;
					
					if(mNextOp == mOps.size())
						return false;
				
					unsigned n = 0;
					
					if(!tryApplyOp(n)) {
						
						for(unsigned i=0; i<n; i++)
						
					}
					
					for(unsigned i=0; 
						
						
							break;
						}
			}
			
			bool tryApplyOp() {				
				for(unsigned i=0; i<mOps[mCurOpN].size(); i++) {	
					
					unsigned tgtDim = mOps[mCurOpN][i].first;
					bool incr = mOps[mCurOpN][i].second;
					
					if((mAdjState[tgtDim] == 0 && !incr) || (mAdjState[tgtDim]+1 == mDomSz[tgtDim] && incr))
						return false;
					
					if(incr)
						mAdjState[tgtDim] += 1;
					else
						mAdjState[tgtDim] -= 1;
				}
				return true;
			}
			
			
			std::vector<AdjOps> const& mOps;
			unsigned mNextOp;
			State mState, mAdjState;
			std::array<bool, N> mChangedDims;
		};
		
		
		
		
		std::vector<unsigned> const& mDimSz;
	};
	
	
	
	template<unsigned N>
	struct CostType {
		using type = double;
	};
	
	template<>
	struct CostType<1> {
		using type = unsigned;
	};
	
	
	template<>
	struct CostType<2> {
		using type = unsigned;
	};
	
	
	
	

	
	
	
	template<unsigned N>
	struct CellGraph {
		
		static_assert(N > 0, "");
		
		using Cost = CostType<N>::type;
	
		
		
		struct OperatorSet {
			OperatorSet(CellGraph const& pG, State const& s)
			{
				//mValidMvs.resize(pG.mAdjOpSet.size());

				std::array<bool,N> dimsAtEdge;

				for(unsigned i=0; i<N; i++)
					if(s[i] == 0 || s[i] == pG.mDimSz[i]-1)
						dimsAtEdge[i] = true;
				
				for(unsigned i=0; i<pG.mAdjOpSet.size(); i++) {
					mValidMvs[i] = pG.mAdjOpSet
			}
			
			unsigned size() {
				return mN;
			}
			
			unsigned operator()(unsigned i) {
				return i;
			}
			private:
			unsigned mN;
			std::vector<unsigned> mValidMvs;
		};
		
		
		
		
		
		CellGraph(std::vector<unsigned> const& pDimSz)
		{
			for(unsigned i=0; i<N; i++) {
				mDimSz[i] = pDimSz.at(i);
				fast_assert(mDimSz[i] > 0);
			}
		}
		
		
		
		const AdjOpSet<N> mAdjOpSet;
	};
	
	template<bool Use_LifeCost>
	struct CellGraph_6 {
		public:
		using Cost_t = int;

		
		CellGraph_4(unsigned pHeight, unsigned pWidth, unsigned pDepth, std::string const& pMapFile) :
			CellMap(pHeight*pWidth*pDepth, pMapFile),
			mHeight(pHeight),
			mWidth(pWidth),
			mDepth(pDepth)
		{}

		template<unsigned Sz>
		const AdjacentCells fillAdjacentCells(std::array<unsigned, Sz>& adj) const {
			AdjacentCells adj{.n=0};
			
			Cost_t costMul = Use_LifeCost ? s/mWidth : 1;
			
			if(s >= mWidth && this->isOpen(s-mWidth))
				adj.adjCells[adj.n++] = s-mWidth;
			if(s < (mHeight-1)*mWidth && this->isOpen(s+mWidth))
				adj.adjCells[adj.n++] = s+mWidth;
			if(s%mWidth != 0 && this->isOpen(s-1))
				adj.adjCells[adj.n++] = s-1;
			if((s+1)%mWidth != 0 && this->isOpen(s+1))
				adj.adjCells[adj.n++] = s+1;
			return adj;
		}
		
		Cost_t getMoveCost(unsigned src, unsigned dst) const {
			return Use_LifeCost ? src/mWidth : 1;
		}

		unsigned getHeight() const {
			return mHeight;
		}
		
		unsigned getWidth() const {
			return mWidth;
		}
		
		private:
		const unsigned mHeight, mWidth;
		
	};






}}}
