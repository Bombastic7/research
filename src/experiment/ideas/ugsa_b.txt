UGSA_B {

var gbl_k
var gbl_fhist		//map of f -> number of base nodes with that ulvl

base_search(s0):
	var openlist	//Ordered by min f
	var closedlist
	
	n0 = {state:s0, g:0, f:abt_search(s0)}
	openlist.push(n0)
	closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		if n.state is goal:
			//return solution...

		informExpansion(n.f)
		
		for edge in children(n.state):
			cn = {	state:	edge.state, 
					g:		n.g + edge.cost, 
					f:		cn.g + abt_search(edge.state)
				}
			
			if (edge.state not in closedlist) or (cn.g < closedlist.find(edge.state).g):
				openlist.push(cn)
				closedlist.add(cn)



abt_search(base_s0):
	s0 = abstract(base_s0)
	
	var openlist	//Ordered by min ug
	var closedlist
	
	n0 = {state:s0, g:0, ug:0, _depth:0}
	openlist.push(n0)
	closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		if n.state is goal:
			return n.g
		
		for edge in children(n.state):
			cn = {	state:	edge.state, 
					g:		n.g+edge.cost, 
					_depth:	n._depth+1,
					ug:		cn.g + gbl_k * compute_hbf() ** cn.g
							// or ug = cn.g + gbl_k * compute_hbf() ** cn._depth  ?
				}
			
			if (edge.state not in closedlist) or (cn.ug < closedlist.find(edge.state).ug):
				openlist.push(cn)
				closedlist.add(cn)


	
informExpansion(u):
	gbl_fhist[u] += 1

compute_hbf():
	var ref_f = gbl_uhist.min_f() //Smallest f lvl
	var ref_cnt = gbl_uhist[ref_f]
	var acc = 0
	
	for (f, cnt) in gbl_fhist:
		acc += (cnt / ref_cnt) ** (1 / (f - ref_f))
	
	return acc / gbl_uhist.size()
}
