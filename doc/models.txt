
--- General pattern ---

class ExampleDomain {

	template<int L> using Domain = .. // Specialisations depending on model //

	ExampleDomainSet(Json const& jConfig);

};


class ExampleDomainLevel {
		
	public:
	
	static const size_t Hash_Range = .. // Methods::hash returns [0, Hash_Range] //
	using Cost = ..
	using Operator = ..
	
	using State = ..
	using PackedState = ..
	
	struct OperatorSet {
		unsigned size();
		Operator operator[](unsigned i);
	};

	struct Edge {	
		State& state();
		Cost cost();
		Operator parentOp();
	};
	
	
	struct Methods {
	
		const Operator noOp;
	
		Methods(ExampleDomain&);
		
		State createState() const;
			
		void packState(State const& pState, PackedState& pPacked) const;
		
		void unpackState(State& pState, PackedState const& pPacked) const;
		
		Edge createEdge(State& pState, pos_t op) const;
		
		void destroyEdge(Edge& pEdge) const;
		
		OperatorSet createOperatorSet(State const& pState) const;
		
		size_t hash(PackedState pPacked) const;
		
		Cost heuristicValue(State const& pState) const ;
		
		.. distanceValue(State const& pState) const;
		
		bool checkGoal(State const& pState) const;

		bool compare(State const& a, State const& b) const;
		
		bool compare(PackedState const& a, PackedState const& b) const;
		
		void prettyPrint(State const& s, std::ostream& out) const;
		
		void prettyPrint(Operator const& op, std::ostream &out) const;
		
		
	};
};



--- Simple model ---

A simple domain follows the general pattern. Domain<0> defined.


--- Abt model ---

Like simple model. Top_Abt_Level constant defined. Domain<0> to Domain<Top_Abt_Level> defined. Domain<L>, where L > 0, need not
implement Methods::createState.

Abstractor<0> to Abstractor<L-1> defined.

struct Abstractor<L> {
	Abstractor(Domain&);
	
	{level L+1 state} operator()({level L state} const&);
};


Example:

struct AbtDomain {
	
	// ExampleDomain declarations
	
	static const unsigned Top_Abt_Level = ..
	
	template<int L> using Abstractor = ..

}
