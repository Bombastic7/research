
ugsa_c(s0):
	var openlist, closedlist //Openlist is ordered on min f, then max g.
	
	var nExpdFront = 0
	var nExpdBack = 0
	
	n0 = {	state:s0, 
			g:0, 
			f:abtsearch(s0),
			depth:0,
			in_op:NOOP,
			parent_op:NOOP,
			parent:null,
			unexpdchildren:null
			}
	openlist.push(n0), closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		
		if n.state is goal:
			//return solution (s0 to n)
		
		var gendChildren = 0
		n.parent.unexpdchildren--
		
		if n.parent.unexpdchildren == 0:
			nExpdFront---
			mExpdBack++
		
		var ops = n.state.ops
		
		for op in ops:
			if op == n.parent_op:
				continue
		
			var Edge e = createEdge(n.state, op)
			
			var childNode = {state:		e.state,
							 g:			n.g+e.cost,
							 depth:		n.depth+1,
							 f:			g+abtsearch(state) * nExpdFront,
							 in_op:		op,
							 parent_op:	e.parent_op,
							 parent:	n,
							 unexpdchildren: null
						}
			
			if closedlist.contains(childNode.state):
				dupNode = closedlist.find(childNode.state)
				
				if dupNode.g > childNode.g:
					closedlist.remove(dupNode)
					
					if openlist.contains(dupNode):
						dupNode.parent.unexpdchildren -= 1
						if dupNode.parent.unexpdchildren == 0:
							nExpdFront--
							nExpdBack++
				
						openlist.remove(dupNode)
				
					openlist.push(childNode)
					closedlist.add(childNode)
					gendChildren++
			
			else:
				openlist.push(childNode)
				closedlist.add(childNode)
				gendChildren++
	
	
		if gendChildren > 0:
			nExpdFront++
		else:
			mExpdBack++

		n.unexpdchildren = gendChildren


ComputeAbtU(g, depth):
	return wf * g + sum([hbf ** i for [i,depth]])


abtsearch(baseState):
	var openlist, closedlist //Openlist is ordered on min u, then max g.

	n0 = {	state:abstract(baseState), 
			g:0, 
			u:0,
			depth:0,
			in_op:NOOP,
			parent_op:NOOP,
			parent:null
			}
	openlist.push(n0), closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		
		if n.state is goal:
			return n.u

		var ops = n.state.ops
		
		for op in ops:
			if op == n.parent_op:
				continue
		
			var Edge e = createEdge(n.state, op)
			
			var childNode = {state:		e.state,
							 g:			n.g+e.cost,
							 depth:		n.depth+1,
							 u:			ComputeAbtU(g, depth),
							 in_op:		op,
							 parent_op:	e.parent_op,
							 parent:	n,
						}
			
			if closedlist.contains(childNode.state):
				dupNode = closedlist.find(childNode.state)
				
				if dupNode.u > childNode.u:
					closedlist.remove(dupNode)
					
					if openlist.contains(dupNode):				
						openlist.remove(dupNode)
				
					openlist.push(childNode)
					closedlist.add(childNode)
			
			else:
				openlist.push(childNode)
				closedlist.add(childNode)
