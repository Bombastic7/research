
UGSA_A {

var gbl_wf, gbl_wt	//Constants
var gbl_exptime		//Time per node expansion
var gbl_uhist		//map of normalised ulvl -> number of base nodes with that ulvl

base_search(s0):
	var openlist, closedlist
	var expd = 0
	
	n0 = {state:s0, g:0, u:abt_search(s0)}
	openlist.push(n0)
	closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		if n.state is goal:
			//return solution...
		
		expd += 1
		
		informExpansion(n->u + expd*gbl_exptime*gbl_wt)
		
		for edge in children(n.state):
			cn = {	state:	edge.state, 
					g:		n.g+edge.cost, 
					u:		cn.g * gbl_wf + abt_search(edge.state)
				}
			
			if (edge.state not in closedlist) or (cn.u < closedlist.find(edge.state).u):
				openlist.push(cn)
				closedlist.add(cn)



abt_search(base_s0):
	s0 = abstract(base_s0)
	
	var openlist, closedlist
	
	n0 = {state:s0, g:0, ug:0}
	openlist.push(n0)
	closedlist.add(n0)
	
	loop:
		n = openlist.pop()
		if n.state is goal:
			return n.ug
		
		for edge in children(n.state):
			cn = {	state:	edge.state, 
					g:		n.g+edge.cost, 
					ug:		compute_ug(cn.g)cn.g * gbl_wf + remexp(ug) * gbl_wt
				}
			
			if (edge.state not in closedlist) or (cn.ug < closedlist.find(edge.state).ug):
				openlist.push(cn)
				closedlist.add(cn)


compute_ug(g):
	var bf = compute_hbf()
	ug = // ug such that ug = g*gbl_wf + gbl_exptime*gbl_wt * bf ** ug
	return ug


informExpansion(u):
	gbl_uhist[u] += 1

compute_hbf():
	var refu = gbl_uhist.min_u() //Smallest u lvl
	var refcnt = gbl_uhist[refu]
	var acc = 0
	
	for (u, cnt) in gbl_uhist:
		acc += (cnt / refcnt) ** (1 / (u - refu))
	
	return acc / gbl_uhist.size()
}
